#![allow(clippy::ptr_arg)]
#![allow(clippy::format_in_format_args)]

use crate::models::{Checklist, Workflow};
use anyhow::Result;
use console::style;
use dialoguer::{Input, MultiSelect, Select};
use std::fs;
use std::path::PathBuf;

pub fn run(project: Option<String>) -> Result<()> {
    let repo_root = find_repo_root()?;
    let checklists_dir = repo_root.join("checklists");

    // Get project
    let project_name = if let Some(p) = project {
        p
    } else {
        let projects = get_existing_projects(&checklists_dir)?;
        if projects.is_empty() {
            println!("{} No projects found", style("✗").red());
            return Ok(());
        }

        let selection = Select::new()
            .with_prompt("Select project")
            .items(&projects)
            .default(0)
            .interact()?;

        projects[selection].clone()
    };

    let project_dir = checklists_dir.join(&project_name);
    let checklist_path = project_dir.join("checklist.md");

    if !checklist_path.exists() {
        println!(
            "{} Checklist not found for project '{}'",
            style("✗").red(),
            project_name
        );
        return Ok(());
    }

    let checklist = Checklist::from_file(&checklist_path)?;

    if checklist.packs.is_empty() {
        println!("{} No packs in checklist", style("✗").red());
        return Ok(());
    }

    // Select pack
    let pack_names: Vec<_> = checklist.packs.iter().map(|p| p.name.as_str()).collect();

    let pack_selection = Select::new()
        .with_prompt("Select pack to generate API test for")
        .items(&pack_names)
        .default(0)
        .interact()?;

    let selected_pack = &checklist.packs[pack_selection];

    // Get workflow file to extract node names
    let workflows_dir = repo_root.join("workflows");
    let workflows = Workflow::load_all(workflows_dir)?;

    let node_types = if let Some(workflow) = workflows.get(&selected_pack.name) {
        workflow.get_unique_node_types()
    } else {
        println!();
        println!(
            "{} No workflow file found for pack '{}'",
            style("⚠").yellow(),
            selected_pack.name
        );
        println!("Generating template with placeholder nodes.");
        println!();
        vec!["PlaceholderNode".to_string()]
    };

    // Select nodes to test
    println!();
    println!("Select nodes to include in API test (Space to toggle, Enter when done):");
    let node_selections = MultiSelect::new().items(&node_types).interact()?;

    let selected_nodes: Vec<_> = node_selections
        .iter()
        .map(|&i| node_types[i].clone())
        .collect();

    if selected_nodes.is_empty() {
        println!("{} No nodes selected", style("✗").red());
        return Ok(());
    }

    // Get server URL
    println!();
    let server_url = Input::<String>::new()
        .with_prompt("Hanzo Studio server URL")
        .default("http://localhost:8188".to_string())
        .interact_text()?;

    // Ask where to save
    let save_options = vec![
        "Local only (api-tests/generated-local/, gitignored)",
        "Commit to repo (api-tests/generated-shared/)",
    ];

    let save_selection = Select::new()
        .with_prompt("Where should this test script be saved?")
        .items(&save_options)
        .default(0)
        .interact()?;

    let api_tests_dir = repo_root.join("api-tests");
    let (output_dir, is_local) = if save_selection == 0 {
        (api_tests_dir.join("generated-local"), true)
    } else {
        (api_tests_dir.join("generated-shared"), false)
    };

    fs::create_dir_all(&output_dir)?;

    // Generate filename
    let filename = format!("test_{}.py", selected_pack.name.replace('-', "_"));
    let output_path = output_dir.join(filename);

    // Generate Python script
    let script_content =
        generate_api_test_script(&selected_pack.name, &selected_nodes, &server_url);

    fs::write(&output_path, script_content)?;

    println!();
    println!("{} API test script generated!", style("✓").green());
    println!("  File: {}", style(output_path.display()).yellow());
    if is_local {
        println!("  {}", style("(local only, gitignored)").dim());
    }
    println!();

    show_instructions(&output_path, &selected_pack.name)?;

    Ok(())
}

fn generate_api_test_script(pack_name: &str, node_types: &[String], server_url: &str) -> String {
    let mut script = format!(
        r#"#!/usr/bin/env python3
"""
API Test Script for: {}
Generated by comfy-qa

Instructions:
1. Start Hanzo Studio server:
   cd /path/to/HanzoStudio
   python main.py

2. Run this script:
   python {}

3. Check results

4. Mark nodes as tested in checklist:
   - [x] NodeName (count) <!-- API tested -->

5. Commit and push

Requirements:
    pip install requests
"""

import requests
import json
import sys

SERVER_URL = "{}"

"#,
        pack_name,
        format!("test_{}.py", pack_name.replace('-', "_")),
        server_url
    );

    // Generate test functions for each node
    for node_type in node_types {
        let test_fn_name = format!("test_{}", node_type.to_lowercase().replace([' ', '-'], "_"));
        script.push_str(&format!(
            r#"
def {}():
    """Test {} functionality"""
    prompt = {{
        "1": {{
            "class_type": "{}",
            "inputs": {{
                # TODO: Add appropriate inputs for this node
                # Check node definition for required inputs
            }}
        }}
    }}

    try:
        response = requests.post(f"{{SERVER_URL}}/prompt", json={{"prompt": prompt}})

        if response.status_code != 200:
            print(f"✗ {} failed: {{response.status_code}}")
            print(f"  Response: {{response.text}}")
            return False

        data = response.json()
        prompt_id = data.get("prompt_id")

        if not prompt_id:
            print(f"✗ {} failed: No prompt_id in response")
            return False

        print(f"✓ {} passed (prompt_id: {{prompt_id}})")
        return True

    except Exception as e:
        print(f"✗ {} failed with exception: {{e}}")
        return False

"#,
            test_fn_name, node_type, node_type, node_type, node_type, node_type, node_type
        ));
    }

    // Generate main function
    script.push_str("\ndef main():\n");
    script.push_str(&format!(
        "    print(\"Testing {} - {} nodes\\n\")\n\n",
        pack_name,
        node_types.len()
    ));
    script.push_str("    tests = [\n");
    for node_type in node_types {
        let test_fn_name = format!("test_{}", node_type.to_lowercase().replace([' ', '-'], "_"));
        script.push_str(&format!("        {},\n", test_fn_name));
    }
    script.push_str("    ]\n\n");
    script.push_str("    passed = sum(1 for test in tests if test())\n");
    script.push_str("    total = len(tests)\n\n");
    script.push_str("    print(f\"\\nResults: {passed}/{total} passed\")\n\n");
    script.push_str("    if passed == total:\n");
    script.push_str("        print(\"✓ All tests passed!\")\n");
    script.push_str("        sys.exit(0)\n");
    script.push_str("    else:\n");
    script.push_str("        print(\"✗ Some tests failed\")\n");
    script.push_str("        sys.exit(1)\n\n");
    script.push_str("if __name__ == \"__main__\":\n");
    script.push_str("    main()\n");

    script
}

fn show_instructions(file_path: &PathBuf, pack_name: &str) -> Result<()> {
    println!("{}", style("═".repeat(70)).cyan());
    println!();
    println!("{}", style("How to Run API Tests:").bold().cyan());
    println!();
    println!("{}", style("Step 1: Start Hanzo Studio Server").bold());
    println!("  cd /path/to/HanzoStudio");
    println!("  python main.py");
    println!();
    println!(
        "{}",
        style("Step 2: Install Dependencies (if needed)").bold()
    );
    println!("  pip install requests");
    println!();
    println!("{}", style("Step 3: Run Test Script").bold());
    println!("  python {}", style(file_path.display()).yellow());
    println!();
    println!("{}", style("Step 4: Mark in Checklist").bold());
    println!("  Open checklists/your-project/checklist.md");
    println!("  Find the pack: {}", pack_name);
    println!(
        "  Add marker: - [x] {} (count) <!-- API tested -->",
        pack_name
    );
    println!();
    println!("{}", style("Step 5: Commit").bold());
    println!("  git add .");
    println!("  git commit -m \"API tested {}\"", pack_name);
    println!("  git push origin main");
    println!();
    println!("{}", style("═".repeat(70)).cyan());
    println!();

    println!("Press Enter to return to dashboard...");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;

    Ok(())
}

fn find_repo_root() -> Result<PathBuf> {
    let current_dir = std::env::current_dir()?;

    for ancestor in current_dir.ancestors() {
        if ancestor.join("checklists").exists() {
            return Ok(ancestor.to_path_buf());
        }
    }

    anyhow::bail!("Could not find repository root")
}

fn get_existing_projects(checklists_dir: &PathBuf) -> Result<Vec<String>> {
    let mut projects = Vec::new();

    if let Ok(entries) = fs::read_dir(checklists_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                if let Some(name) = path.file_name().and_then(|s| s.to_str()) {
                    if name != "templates" && name != "schema" {
                        projects.push(name.to_string());
                    }
                }
            }
        }
    }

    projects.sort();
    Ok(projects)
}
